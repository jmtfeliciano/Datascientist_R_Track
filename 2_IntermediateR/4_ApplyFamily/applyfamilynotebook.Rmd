---
title: "Apply Family"
output: html_notebook
---

#### Basics of Apply

Apply allows us to simplify tasks by applying all items in a list/vector/matrix to a function without having to write a complicated for loop statement to iterate over the data structure we want to analyze.

#### Basics on apply

There's a family of apply function but let us examine `lapply()` and using it to split four data by cutting the semi-colon and making all entries small letters.

Again, we need to use `strsplit()` to split our character data and eventually need to use `tolower()` to transform letters into small.

```{r}
# vector with pioneers and their birth year
pioneers <- c("GAUSS:1777", "BAYES:1702", "PASCAL:1623", "PEARSON:1857")
# split them using strsplit() and inspect how it looks like before proceeding
split_data <- strsplit(pioneers, ":")
split_data

# now, turn all data into small letters by using lapply() and tolower():
split_low <- lapply(split_data, tolower)
# now reprint the data with small letters
split_low
```

By looking at the latest data, the letters were indeed transformed into small letters.

Do notice that the data returned by `lapply()` is a list.  To transform a list into an array, we can utilize `unlist()` to our finalized list called `split_low`

```{r}
# split_low, which we solved for above. is a list.
str(split_low)

# now unlist our data
unlist(split_low)
```

Now, all our data is in a nice sequential vector.  `unlist()` as stated is a great tool to simply data.

#### Using anonymous and custom functions in apply

Instead of using functions already in the workspace, we can pass an anonymous or our custom function to the family of apply functions.  Suppose we want to split the name and years of our data into two seperate datasets. Here is an example with using custom function I made from scratch and passing it as an anonymous an example:

```{r}
# Code from previous exercise:
pioneers <- c("GAUSS:1777", "BAYES:1702", "PASCAL:1623", "PEARSON:1857")
split <- strsplit(pioneers, split = ":")
split_low <- lapply(split, tolower)

# Write function select_first()
select_first <- function(x) {
  x[1]
}
# PASSING A CUSTOM FUNCTION:  Applies select_first function over split_low and names it 'names'
names <- lapply(split_low, select_first)
names

# PASSING AN ANONYMOUS FUNCTION: Feeds split_low and an anonymous example to lapply.. call the result 'years'
years <- lapply(split_low, select_second)
years
```

#### sapply() method

`lapply()` returns a list that we can transform into a vector by using `unlist()`

But `sapply()` attempts to simplify our data into a vector or matrix.  It is supposed to be user-friendly.

Now let's play around some data and `sapply()`.  Suppose we have a vector of city names and we want to count the number of characters using the built-in `nchar()` method in R.

```{r}
cities <- c("London", "Prague", "Los Angeles", "Berlin")

# using lapply() to get a vector of character number
unlist(lapply(cities, nchar))

# using sapply() to get a vector of character number
sapply(cities, nchar)
```

The beauty of sapply is that the vector returned corresponds to the original data so we know which data corresponds to which data.

But if we do not want the names, we can pass USE.NAMES = FALSE as a paramater to `sapply()`.  Here is the example:

```{r}
sapply(cities, nchar, USE.NAMES = FALSE) 
```

#### Problem with sapply()

The main issue with sapply() is that it forces to simply the results and the behavior can be unpredictable.  In the previous example, it simply returned a numerical value for each data.  But when you are processing multiple data output, the behavior can be predictable.  

Suppose we want to use `sapply()` to break down individual cities into their characters by using strsplit()
```{r}
cities <- c("London", "Prague", "Los Angeles", "Berlin")
# A function I created to split city names into individual characters
splitted_cities <- sapply(cities, function (city) {
  return(strsplit(city, ""))
})

# Returns the product of sapply()
splitted_cities 

# Prints the structure of this data
str(splitted_cities)

```

As revealed by the `str()` script, splitted_cities returned a list.  As stated earlier, `sapply()` forces the results into a vector or matrix.  But the unpredictability can sometimes force the result into a list if it does not know what to do. 



